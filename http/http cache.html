<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器 HTTP 缓存的分类 | FE Docs</title>
    <meta name="description" content="前端知识点">
    <link rel="icon" href="/img/logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.a34719c3.css" as="style"><link rel="preload" href="/assets/js/app.9202526c.js" as="script"><link rel="preload" href="/assets/js/2.0bd3c2b9.js" as="script"><link rel="preload" href="/assets/js/65.4b1099ce.js" as="script"><link rel="prefetch" href="/assets/js/10.bd609520.js"><link rel="prefetch" href="/assets/js/11.04c9f9f2.js"><link rel="prefetch" href="/assets/js/12.1174208b.js"><link rel="prefetch" href="/assets/js/13.0cefea28.js"><link rel="prefetch" href="/assets/js/14.79fb146c.js"><link rel="prefetch" href="/assets/js/15.be73da20.js"><link rel="prefetch" href="/assets/js/16.81fd60a9.js"><link rel="prefetch" href="/assets/js/17.1289b355.js"><link rel="prefetch" href="/assets/js/18.b8c2880b.js"><link rel="prefetch" href="/assets/js/19.a0199846.js"><link rel="prefetch" href="/assets/js/20.5cf227c8.js"><link rel="prefetch" href="/assets/js/21.b578aa13.js"><link rel="prefetch" href="/assets/js/22.1bcab7d5.js"><link rel="prefetch" href="/assets/js/23.aa2af606.js"><link rel="prefetch" href="/assets/js/24.50b1b50b.js"><link rel="prefetch" href="/assets/js/25.5c2f738b.js"><link rel="prefetch" href="/assets/js/26.170e5604.js"><link rel="prefetch" href="/assets/js/27.008e5464.js"><link rel="prefetch" href="/assets/js/28.d6a76cff.js"><link rel="prefetch" href="/assets/js/29.886415d8.js"><link rel="prefetch" href="/assets/js/3.aa957b6d.js"><link rel="prefetch" href="/assets/js/30.8ddeec88.js"><link rel="prefetch" href="/assets/js/31.9e1dc344.js"><link rel="prefetch" href="/assets/js/32.0b730d68.js"><link rel="prefetch" href="/assets/js/33.50b7ab4a.js"><link rel="prefetch" href="/assets/js/34.f04ca624.js"><link rel="prefetch" href="/assets/js/35.9364d72b.js"><link rel="prefetch" href="/assets/js/36.e3f7b10b.js"><link rel="prefetch" href="/assets/js/37.24228c26.js"><link rel="prefetch" href="/assets/js/38.c0bcf574.js"><link rel="prefetch" href="/assets/js/39.f2b5e7ae.js"><link rel="prefetch" href="/assets/js/4.776227d8.js"><link rel="prefetch" href="/assets/js/40.e47cdc1f.js"><link rel="prefetch" href="/assets/js/41.253efb42.js"><link rel="prefetch" href="/assets/js/42.b0b351ae.js"><link rel="prefetch" href="/assets/js/43.bed80170.js"><link rel="prefetch" href="/assets/js/44.c0da1ee3.js"><link rel="prefetch" href="/assets/js/45.60965407.js"><link rel="prefetch" href="/assets/js/46.3aaf5ec5.js"><link rel="prefetch" href="/assets/js/47.7de03435.js"><link rel="prefetch" href="/assets/js/48.88cbf3a3.js"><link rel="prefetch" href="/assets/js/49.784ac747.js"><link rel="prefetch" href="/assets/js/5.c6bb2bbc.js"><link rel="prefetch" href="/assets/js/50.c856075f.js"><link rel="prefetch" href="/assets/js/51.8cbac95f.js"><link rel="prefetch" href="/assets/js/52.48fe9251.js"><link rel="prefetch" href="/assets/js/53.7d9e9f6a.js"><link rel="prefetch" href="/assets/js/54.c8adb72f.js"><link rel="prefetch" href="/assets/js/55.7b9aa458.js"><link rel="prefetch" href="/assets/js/56.932acbaa.js"><link rel="prefetch" href="/assets/js/57.6d60c0a4.js"><link rel="prefetch" href="/assets/js/58.03e0047f.js"><link rel="prefetch" href="/assets/js/59.b1e2bb0e.js"><link rel="prefetch" href="/assets/js/6.f0da9310.js"><link rel="prefetch" href="/assets/js/60.bd7f88a3.js"><link rel="prefetch" href="/assets/js/61.8c926ed5.js"><link rel="prefetch" href="/assets/js/62.e6e861da.js"><link rel="prefetch" href="/assets/js/63.3cfa8c57.js"><link rel="prefetch" href="/assets/js/64.14aa4fbe.js"><link rel="prefetch" href="/assets/js/66.582be268.js"><link rel="prefetch" href="/assets/js/67.2f271952.js"><link rel="prefetch" href="/assets/js/68.f375e389.js"><link rel="prefetch" href="/assets/js/69.f3182f58.js"><link rel="prefetch" href="/assets/js/7.d93aaab5.js"><link rel="prefetch" href="/assets/js/70.40a3d88d.js"><link rel="prefetch" href="/assets/js/71.d024a182.js"><link rel="prefetch" href="/assets/js/8.89bf9ff8.js"><link rel="prefetch" href="/assets/js/9.0807a584.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a34719c3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">FE Docs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/fe/" class="nav-link">前端</a></div><div class="nav-item"><a href="/vuesource/" class="nav-link">Vue源码分析</a></div><div class="nav-item"><a href="/http/" class="nav-link router-link-active">HTTP</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/fe/" class="nav-link">前端</a></div><div class="nav-item"><a href="/vuesource/" class="nav-link">Vue源码分析</a></div><div class="nav-item"><a href="/http/" class="nav-link router-link-active">HTTP</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>HTTP</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/http/" class="sidebar-link">介绍</a></li><li><a href="/http/http cache.html" class="active sidebar-link">浏览器 HTTP 缓存的分类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/http/http cache.html#强缓存" class="sidebar-link">强缓存</a></li><li class="sidebar-sub-header"><a href="/http/http cache.html#协商缓存" class="sidebar-link">协商缓存</a></li><li class="sidebar-sub-header"><a href="/http/http cache.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/http/TCPIP 分层.html" class="sidebar-link">TCP/IP 分层管理</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器-http-缓存的分类"><a href="#浏览器-http-缓存的分类" class="header-anchor">#</a> 浏览器 HTTP 缓存的分类</h1> <p><img src="/img/httpCache.png" alt="HTTP 缓存"></p> <p>浏览器 HTTP 缓存分两钟：</p> <ol><li>强缓存</li> <li>协商缓存</li></ol> <p><strong>强缓存</strong>指的是浏览器在本地判定缓存有无过期，未过期直接从内存或磁盘读取缓存，整个过程不需要和服务器通信。</p> <p><strong>协商缓存</strong>需要向服务器发送一次协商请求，请求时带上和协商缓存相关的请求头，由服务器判断缓存是否过期，未过期就返回状态码 304，浏览器当发现响应的返回码是 304，也直接是读取本地缓存，如果服务器判定过期就直接返回请求资源和 last-modified，状态码为 200。</p> <h3 id="强缓存和协商缓存的区别"><a href="#强缓存和协商缓存的区别" class="header-anchor">#</a> 强缓存和协商缓存的区别</h3> <ol><li>命中时状态码不同。强缓存返回 200，协商缓存返回 304。</li> <li>优先级不同。先判定强缓存，强缓存判断失败再判定协商缓存。</li> <li>强缓存的收益高于协商缓存，因为协商缓存相对于强缓存多了一次协商请求</li></ol> <h2 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h2> <h3 id="pragma"><a href="#pragma" class="header-anchor">#</a> Pragma</h3> <p>progma 是 HTTP1.0 时期的产物，和后面要说的 cache-control 作用差不多，它的值只能设置为 <code>no-cache</code>。与 Cache-Control: no-cache 效果一致，即禁用强缓存，只能使用协商缓存。</p> <h3 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h3> <p>有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对 HTTP1.0 而言，Expires 就是做这件事的首部字段。 Expires 的值对应一个GMT（格林尼治时间），比如<code>Mon, 22 Jul 2002 11:12:01 GMT</code>来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。</p> <p>因为 expires 是一个时间值，如果服务器和客户端是系统时间差较大，就会引起缓存混乱。</p> <h3 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h3> <p>HTTP 1.1 中增加的字段，被设计用来替代 pragma。cache-control 这个头部字段既可以用在请求头也可以用在响应头中。</p> <h3 id="优先级"><a href="#优先级" class="header-anchor">#</a> 优先级</h3> <p><strong>Pragma -&gt; Cache-Control -&gt; Expires</strong> 。</p> <table><thead><tr><th style="text-align:left;">头部</th> <th style="text-align:left;">可选值</th> <th style="text-align:left;">优先级</th></tr></thead> <tbody><tr><td style="text-align:left;">Pragma(HTTP/1.0)</td> <td style="text-align:left;">no-cache:不直接使用缓存</td> <td style="text-align:left;">高</td></tr> <tr><td style="text-align:left;">Cache-Control(HTTP/1.1)</td> <td style="text-align:left;">1. no-cache：不直接使用缓存   2. no-store:不直接使用缓存，每次都是下载最新资源  3.max-age：xx秒，缓存时常  4. public/private：是否只能被单个用户使用，默认为private  5. must-revalidate：每次访问需要缓存校验</td> <td style="text-align:left;">中</td></tr> <tr><td style="text-align:left;">Expires(HTTP/1.0+)</td> <td style="text-align:left;">GMT 时间</td> <td style="text-align:left;">低</td></tr></tbody></table> <h2 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h2> <p>协商缓存中那几个首部字段是<strong>配对使用</strong>的，即：</p> <ul><li>请求头 if-modified-since 和响应头 last-modified</li> <li>请求头 if-none-match 和响应头 etag</li></ul> <h3 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h3> <p>服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p> <div class="language- extra-class"><pre class="language-text"><code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
</code></pre></div><p>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回<code>304</code>状态码，<strong>内容为空</strong>，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回<code>200</code>状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个<code>304</code>响应比一个静态资源通常小得多，这样就节省了网络带宽。</p> <h3 id="etag"><a href="#etag" class="header-anchor">#</a> ETag</h3> <p>为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了 <strong>ETag 实体首部</strong>字段。 服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code>Etag<span class="token punctuation">:</span> <span class="token string">&quot;5d8c72a5edda8d6a:3239&quot;</span>
</code></pre></div><p>客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。
如果服务器发现ETag匹配不上，那么直接以常规GET <code>200</code>回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回<code>304</code>知会客户端直接使用本地缓存即可。
那么客户端是如何把标记在资源上的 ETag 传回给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值：</p> <h4 id="优先级-2"><a href="#优先级-2" class="header-anchor">#</a> 优先级</h4> <p><strong>if-none-match &gt; if-modified-since</strong></p> <p>当服务器收到的请求中同时包含 if-modified-since 和 if-none-match 时，服务器会忽略 if-modified-since。</p> <table><thead><tr><th style="text-align:left;">头部</th> <th style="text-align:left;">可选值</th> <th style="text-align:left;">优先级</th> <th>优缺点</th></tr></thead> <tbody><tr><td style="text-align:left;">ETag/If-None-Match（HTTP/1.1）</td> <td style="text-align:left;">校验值</td> <td style="text-align:left;">高</td> <td>1. 默认使用 hash算法，分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。2. 精确的判断资源有无被修改，可识别一秒内的修改次数 3. 计算 ETag 需要性能消耗</td></tr> <tr><td style="text-align:left;">Last-Modified/If-Modified-Sincel(HTTP/1.1)</td> <td style="text-align:left;">1. no-cache：不直接使用缓存   2. no-store:不直接使用缓存，每次都是下载最新资源  3.max-age：xx秒，缓存时常  4. public/private：是否只能被单个用户使用，默认为private  5. must-revalidate：每次访问需要缓存校验</td> <td style="text-align:left;">低</td> <td>1. 只要资源修改，无论内容有无变化，都会将资源返回客户端 2.以时刻为标识，无法获取一秒内的修改变化 3. 某些服务器不能准确获取最后修改时间</td></tr></tbody></table> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <table><thead><tr><th style="text-align:left;">头部</th> <th style="text-align:left;">优势和特点</th> <th style="text-align:left;">劣势和问题</th></tr></thead> <tbody><tr><td style="text-align:left;">Expires</td> <td style="text-align:left;">1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。 2、以时刻标识失效时间。</td> <td style="text-align:left;">1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。 2、存在版本问题，到期之前的修改客户端是不可知的。</td></tr> <tr><td style="text-align:left;">Cache-Control</td> <td style="text-align:left;">1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。 2、比Expires多了很多选项设置。</td> <td style="text-align:left;">1、HTTP 1.1 才有的内容，不适用于HTTP 1.0 。 2、存在版本问题，到期之前的修改客户端是不可知的。</td></tr> <tr><td style="text-align:left;">Last-Modified</td> <td style="text-align:left;">1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。</td> <td style="text-align:left;">1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。 2、以时刻作为标识，无法识别一秒内进行多次修改的情况。 3、某些服务器不能精确的得到文件的最后修改时间。</td></tr> <tr><td style="text-align:left;">ETag</td> <td style="text-align:left;">1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。 2、不存在版本问题，每次请求都回去服务器进行校验。</td> <td style="text-align:left;">1、计算ETag值需要性能损耗。 2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。</td></tr></tbody></table></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">3/23/2020, 5:33:06 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/http/" class="prev router-link-active">介绍</a></span> <span class="next"><a href="/http/TCPIP 分层.html">TCP/IP 分层管理</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9202526c.js" defer></script><script src="/assets/js/2.0bd3c2b9.js" defer></script><script src="/assets/js/65.4b1099ce.js" defer></script>
  </body>
</html>
