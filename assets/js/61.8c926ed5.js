(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{197:function(t,e,a){"use strict";a.r(e);var s=a(0),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"计算属性和侦听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算属性和侦听器"}},[t._v("#")]),t._v(" 计算属性和侦听器")]),t._v(" "),a("h2",{attrs:{id:"computed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),a("p",[t._v("计算属性的本质其实是一个 "),a("code",[t._v("lazy watcher")]),t._v(" ,在进行取值操作是并不会立刻求值，当其相关依赖项发生变化时会将自身标记属性 "),a("code",[t._v("dirty")]),t._v(" 置为 true 才会重新计算结果否则返回上一次的结果，相当于缓存结果。")]),t._v(" "),a("h2",{attrs:{id:"computed-缓存-vs-methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-缓存-vs-methods"}},[t._v("#")]),t._v(" computed 缓存 VS methods")]),t._v(" "),a("p",[a("strong",[t._v("computed是基于它们的响应式依赖进行缓存的")]),t._v(",在相关响应式依赖发生改变时它们才会重新求值")]),t._v(" "),a("p",[t._v("触发重新渲染时，methods"),a("strong",[t._v("总会")]),t._v("执行")]),t._v(" "),a("h2",{attrs:{id:"computed-vs-watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-vs-watch"}},[t._v("#")]),t._v(" computed VS watch")]),t._v(" "),a("p",[a("code",[t._v("watch")]),t._v(" 可以执行"),a("strong",[t._v("异步任务")])]),t._v(" "),a("p",[a("code",[t._v("computed")]),t._v(" 不能执行异步任务，计算属性必须"),a("strong",[t._v("同步执行")])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("ul",[a("li",[t._v("当你在模板内使用了复杂逻辑的表达式时，你应当使用计算属性。")]),t._v(" "),a("li",[t._v("虽然方法也能实现同样的效果，但是因为计算属性可以基于它们的依赖进行缓存，所以选择计算属性会比方法更优。")]),t._v(" "),a("li",[t._v("当需要在数据变化时执行异步或开销较大的操作时，可以使用 watch。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/computed.png",alt:"computed"}})])])}),[],!1,null,null,null);e.default=v.exports}}]);